---
title: "Data for DSAF POC"
author: "Kiyomi Ferguson"
date: "2025-10-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(patchwork)
library(here)
library(terra)
```

## Notes/Updates: we don't want to distract with the Canada vs. USA thing so there have been some manipulations 

* Region names have all been changed from Canada and USA to Region 1 and Region 2 respectively 
* **Centre of Gravity:**  
  * for Region1 have been moved west into 4XW and Region 2 from USA into Newfoundland.  
  * Although we originally included the median and ,5th & 95th quantile in the data, because they were not used in the construction of the POC, here, I did not calculate new values for them, and instead removed them. 
* **Distance to border:**  
  * For POC, the Hague Line has been replaced with a theoretical administrative  border (which, based on NAFO divisions, runs between the Scotian shelf and Newfoundland ). 
  * **Path to shape file: Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/TheorheticalBorder_Shapefile/AdministrativeBorder.shp** 
  * Distance to border values were not recalculated based on the new administrative border and COG values (because the trends are similar enough for the purpose of the POC) 
  * **HOWEVER**, because the COG for Region 1 is now west of the border, and Region 2 is now East of it:
    * The signs from the original data have been reversed 
    * The timeline on Region1 has been reversed so that it approaches the border (the direction for Region 2 is appropriately drifting away, so it has been left alone).  
  * **Path to new data files: Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/...manipulated.csv** 
  * Exception: Range Edge did not have a regional component so it is unaffected, so it was just copied to this file. 

## Overview of Data for Proof of Concept 
Assembled in **Prepare data for POC.R**, the **Data_SHinyApp_Proof_of_Concept folder** contains data for the temporal (and spatial where applicable*) timeseries for the 6 shift indicators, calculated based on Atlantic halibut abundance estimates form SDM output. All data have been subset to spring estimates.

1. Abundance*: total annual estimated abundance  

2. Area Occupied: the total area containing 90% of the abundance 

3. Abundance-Weighted Depth: the average depth, weighted by abundance, the average depth where most of the population is found, (telling us the depth preference) 

4. Range Edge*: the geographical minimum (5%) and maximum (95%) of modeled abundance 

5. Centre of Gravity*: the average latitude and longitude, weighted by abundance 

6. Distance from COG to shared border : the shortest path (without crossing land) from the COG to the nearest point on the international border 

7. Scaled Slopes:  lm slopes for 2006-2023 (the period when the water began warming rapidly), scaled  so that all indicators are in the same units


## 1. Abundance 

**Data: POC_Abundance.csv**

Total annual estimated spring-time abundance per region. Derived from indexed estimates calculated with the model run. 

* Region: USA, Canada

* Year: 1990-2023

* Estimate: Total annual estimated spring-time abundance (count)

* SD: Standard Deviation 

* X: Unique identifier

```{r abundance data, echo=FALSE}
POC_Abundance<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_Abundance_manipulated.csv"))
str(POC_Abundance)

```

### Timeseries: Abundance Estimate 

```{r abundance plot, echo=FALSE, fig.width=6, fig.height=4}
ggplot(POC_Abundance, 
       aes(x = Year, y = Estimate, colour = Region, group = Region)) +
  geom_line() +
  geom_ribbon(aes(ymin = Estimate - SD,
                  ymax = Estimate + SD,
                  fill = Region), 
              alpha = 0.25, colour = NA) +
  theme_bw() +
  labs(x = "Year", y = "Abundance Estimate",
       colour = "Region", fill = "Region")

```

### Annual rasters for total estimated abundance (Spring)

These are in the **EstAbundanceRasters** folder 1990-2023,  for both raw and square root values. They were compiled in **EstAbundanceRasters.R**

```{r abundance rasters, echo=FALSE, fig.width=4, fig.height=4}
r_squrt <- rast(here::here("Data/Data_SHinyApp_Proof_of_Concept/EstAbundanceRasters/Est_Abun_Sqrt2022.tif"))
r_raw <- rast(here::here("Data/Data_SHinyApp_Proof_of_Concept/EstAbundanceRasters/Est_Abun_Raw2022.tif"))

plot(r_raw, main = "Raw Est 2022")
plot(r_squrt, main = "Sqrt_Est_2022")

```

## 2. Area Occupied 

**Data: POC_AreaOccupied.csv**

The total area containing 50%, 75%, 90%, and 95% of the abundance. This calculation first took the Abundance estimates per grid location, subset for Spring, calculated the total annual spring abundance by region and year ($TotalSpringAbundance). Next, it Calculated how much area (in km²) is needed to account for 50%, 75%, 90%, and 95% of total abundance within each Region and Year of the dataset using a running total of abundance as cells are added from highest to lowest abundance.

* Region: USA or Canada 

* Year: 1990-2023

* Threshold:  50%, 75%, 90%, 95% 

* Total_Abundance: Total springtime abundance in that Region and Year (sum of all cells).

* Total_Area: Total area (km²) of all grid cells in that Region and Year (cumulative running total).

* Area_Threshold: The total area (km²) required to reach that abundance threshold.

* Percent_Area_Used: The percentage of total area needed to contain the threshold proportion of abundance.

* n_cells: Number of spatial cells required to reach the threshold abundance.

* Area_Efficiency: = space used per unit of abundance...is abundance more concentrated or dispersed

```{r AO data, echo=FALSE}
POC_AO<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_AreaOccupied_manipulated.csv"))
str(POC_AO)
POC_AO_sub<-subset(POC_AO, POC_AO$Threshold ==90)
```

### Timeseries : Total area occupied ( 90% of abundance), Percent of the total area used, Area Efficiency  

```{r AO plot, echo=FALSE, fig.width=12, fig.height=4}
AO1<-ggplot(POC_AO_sub, 
       aes(x = Year, y = Area_Threshold, colour = Region, group = Region)) +
  geom_line() +
  theme_bw() +
  labs(x = "Year", y = "Total km² occupied (90% Abundance)",
       colour = "Region", fill = "Region")+
  theme(legend.position = "none")

AO2<-ggplot(POC_AO_sub, 
       aes(x = Year, y = Percent_Area_Used, colour = Region, group = Region)) +
  geom_line() +
  theme_bw() +
  labs(x = "Year", y = "Percent of Area Used (90% Abundance)",
       colour = "Region", fill = "Region")+
  theme(legend.position = "none")

AO3<-ggplot(POC_AO_sub, 
            aes(x = Year, y =Area_Efficiency , colour = Region, group = Region)) +
  geom_line() +
  theme_bw() +
  labs(x = "Year", y = "Area Efficiency (90% Abundance)",
       colour = "Region", fill = "Region")

AO1 + AO2 + AO3 + plot_layout(widths = c(1, 1, 1.2))
```

## 3. Abundance-Weighted Depth

**Data: POC_AWD.csv**

The mean, median, Q5, and Q95 depth, weighted by estimated abundance values 

* Region: USA, Canada

* Year: 1990-2023 

* Depth distribution values (m): Mean, Median, Q5, Q95 

```{r AWD data, echo=FALSE}
POC_AWD<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_AWD_manipulated.csv"))
str(POC_AWD)

```

### Timeseries: Abundance-Weighted Depth

```{r AWD plot, echo=FALSE, fig.width=6, fig.height=4}

ggplot(POC_AWD, 
       aes(x = Year, y = Depth_Median , colour = Region, group = Region)) +
  geom_line() +
  geom_ribbon(aes(ymin = Depth_Q5,
                  ymax = Depth_Q95,
                  fill = Region), 
              alpha = 0.25, colour = NA) +
  theme_bw() +
  labs(x = "Year", y = "Depth (m)",
       colour = "Region", fill = "Region")
```

## 4. Range Edge 

**Data: POC_RangeEdge.csv**

Annual location of leading and trailing edges for the entire stock 
The 5th percentile (trailing edge), 50th, and  95th percentile (leading edge) of the species' spatial distribution were calculated using a weighted quantile of the coordinate values (weighted by abundance estimates).  


Units are in km East/West, so here,  we also convert them to a geographic coordinate system so that they can be plotted on a map (convert_km_to_wgs84) 

* Year: 1990-2023

* Trailing Edge Variables (5th, USA): Estimate_km_E_quantile_0.05, Estimate_km_N_quantile_0.05, Std_Dev_km_N_quantile_0.05, Std_Dev_km_E_quantile_0.05

* Centroid Variables (50th): Estimate_km_E_quantile_0.5, Estimate_km_N_quantile_0.5, Std_Dev_km_E_quantile_0.5, Std_Dev_km_N_quantile_0.5

* Leading Edge Variables (95th, Canada): Estimate_km_E_quantile_0.95, Estimate_km_N_quantile_0.95,  Std_Dev_km_E_quantile_0.95, Std_Dev_km_N_quantile_0.95

```{r RE data, echo=FALSE}
RE_DAT<- read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_RangeEdge.csv"))
str(RE_DAT)
```

### Timeseries: Leading and Trailing Edges 
```{r Range Edge plot, echo=FALSE, warning=FALSE, message=FALSE,  results='hide', fig.width=10, fig.height=9}
#Prep-work for  mapping Range Edge, copied from 4_FancyFigs_RangeEdgeEAO_KFedits.R (line 439)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
#library(rnaturalearthhires)
library(dplyr)
library(geosphere)
library(ggpmisc)
#prep data for plotting
#separate each set of coordinates into their own objects
Est_0.05<-RE_DAT[ , c("Year","Estimate_km_E_quantile_0.05", "Estimate_km_N_quantile_0.05" )]
Est_0.5<-RE_DAT[ , c("Year", "Estimate_km_E_quantile_0.5",  "Estimate_km_N_quantile_0.5")] 
Est_0.95<-RE_DAT[ , c("Year", "Estimate_km_E_quantile_0.95",  "Estimate_km_N_quantile_0.95")] 
Std_0.05<-RE_DAT[ , c("Year", "Std_Dev_km_E_quantile_0.05",  "Std_Dev_km_N_quantile_0.05")]
Std_0.5<-RE_DAT[ , c("Year", "Std_Dev_km_E_quantile_0.5", "Std_Dev_km_N_quantile_0.5")] 
Std_0.95<-RE_DAT[ , c("Year", "Std_Dev_km_E_quantile_0.95", "Std_Dev_km_N_quantile_0.95")] 

# Convert from km to m,  make sf object in local UTM (meters), and reproject
convert_km_to_wgs84 <- function(df, east_col, north_col) {
  # Convert from km to m
  df[[east_col]] <- df[[east_col]] * 1000
  df[[north_col]] <- df[[north_col]] * 1000
  # Make sf object in local CRS
  pts_local <- st_as_sf(df, coords = c(east_col, north_col), crs = "EPSG:32621")
  # Reproject to WGS84
  pts_wgs84 <- st_transform(pts_local, crs = 4326)
  return(pts_wgs84)
}

#Trailing edge Estimates
Est_0.05_pts <- convert_km_to_wgs84(
  Est_0.05,
  east_col = "Estimate_km_E_quantile_0.05",
  north_col = "Estimate_km_N_quantile_0.05"
)
#Mean Estimates
Est_0.5_pts <- convert_km_to_wgs84(
  Est_0.5,
  east_col = "Estimate_km_E_quantile_0.5",
  north_col = "Estimate_km_N_quantile_0.5"
)
#Leadind edge Estimates
Est_0.95_pts <- convert_km_to_wgs84(
  Est_0.95,
  east_col = "Estimate_km_E_quantile_0.95",
  north_col = "Estimate_km_N_quantile_0.95"
)
#Trailing edge Standard Deviation
Std_0.05_pts <- convert_km_to_wgs84(
  Std_0.05,
  east_col = "Std_Dev_km_E_quantile_0.05",
  north_col = "Std_Dev_km_N_quantile_0.05"
)
#Mean Standard Deviation
Std_0.5_pts <- convert_km_to_wgs84(
  Std_0.5,
  east_col = "Std_Dev_km_E_quantile_0.5",
  north_col = "Std_Dev_km_N_quantile_0.5"
)
#Leading edge Standard Deviation
Std_0.95_pts <- convert_km_to_wgs84(
  Std_0.95,
  east_col = "Std_Dev_km_E_quantile_0.95",
  north_col = "Std_Dev_km_N_quantile_0.95"
)

#Prep spatial data for plotting: 
Land <- ne_countries(scale = "large", returnclass = "sf")#high resolution land shapefile
crs <- st_crs(Std_0.95_pts)
#bounding box for plotting: 
study_area_bbox <- st_bbox(c(xmin = -80, ymin = 30, xmax = -44, ymax = 60))
study_area_polygon <- st_as_sfc(study_area_bbox)
st_crs(study_area_polygon) <- crs

#Read shapefiles match projections, and clip to bounding box
  All_region <- st_read(here::here("", "R/Shapefiles/IndexShapefiles/Full_RegionAl14.shp"))
  EEZ <- st_read(here::here("", "Data/Mapping_shapefiles/EEZ.shp"))
  contours <- st_read(here::here("", "Data/Mapping_shapefiles/GEBCO_DepthContours.shp"))
  NAFO <-st_read(here::here("", "Data/Mapping_shapefiles/Divisions.shp"))
  AdminiBoder <-  st_read(here::here("", "Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/TheorheticalBorder_Shapefile/AdministrativeBorder.shp"))
    All_region<- st_transform (All_region, crs)
    EEZ <- st_transform (EEZ, crs)
    contours <- st_transform (contours, crs)
    NAFO <- st_transform (NAFO, crs)
    AdminiBoder <- st_transform (AdminiBoder, crs)
      sf::sf_use_s2(FALSE)   # revert to GEOS-based operations
      EEZ <- st_intersection(EEZ, study_area_polygon)
      contours <- st_intersection(contours, study_area_polygon)
      NAFO <- st_intersection(NAFO, study_area_polygon)

#Plotting function for mapping leading and trailing edges
RangeEdge_Mapped <-  ggplot() +
  #start with mapping shapefiles 
  geom_sf(data = contours, color="lightblue", linewidth = .4) +
  geom_sf(data = All_region,  fill = NA) +
  geom_sf(data = NAFO, color="dimgrey", fill = NA) +
  geom_sf(data = AdminiBoder, color="black", linewidth = 1) +
  geom_sf(data = EEZ, color="black", linetype = "dashed", linewidth  = 1) +
  geom_sf(data = Land , color = "black", fill = "cornsilk") +
  #coord_sf(xlim = c(-72, -47), ylim = c(41, 50), expand = FALSE) 
  
  #Add Trailing Edge
  # Path connecting points by year
  geom_path(data = Est_0.05_pts %>% 
              st_coordinates() %>% 
              as.data.frame() %>% 
              cbind(Year = Est_0.05_pts$Year) %>% 
              arrange(Year),
            aes(x = X, y = Y, color = Year),
            linewidth = 0.8) +
  # Regular points for 0.05 quantile
  geom_sf(data = Est_0.05_pts, 
          aes(color = Year),
          na.rm = TRUE, 
          alpha = 1, 
          size = 2, 
          shape = 19)+
  # Larger terminal point for 0.05 quantile (most recent year)
  geom_sf(data = Est_0.05_pts[Est_0.05_pts$Year == max(Est_0.05_pts$Year, na.rm = TRUE), ],
          aes(color = Year),
          #position = pos_jitter, 
          na.rm = TRUE, 
          alpha = 1, 
          size = 5, 
          shape = 19) +
  # Annotation for 0.05 quantile terminal point
  annotate("text",
           x=-64.5, y=42.1,
           label = "Trailing Edge",
           color = "black",
           size = 5,
           family = "serif") +
  #add Leading Edge 
  # Path connecting points by year
  geom_path(data = Est_0.95_pts %>% 
              st_coordinates() %>% 
              as.data.frame() %>% 
              cbind(Year = Est_0.95_pts$Year) %>% 
              arrange(Year),
            aes(x = X, y = Y, color = Year),
            linewidth = 0.8) +
  # Regular points for 0.95 quantile
  geom_sf(data = Est_0.95_pts, 
          aes(color = Year),
          na.rm = TRUE, 
          alpha = 1, 
          size = 2, 
          shape = 19)+
  # Larger terminal point for 0.95 quantile (most recent year)
  geom_sf(data = Est_0.95_pts[Est_0.95_pts$Year == max(Est_0.95_pts$Year, na.rm = TRUE), ],
          aes(color = Year),
          #position = pos_jitter, 
          na.rm = TRUE, 
          alpha = 1, 
          size = 5, 
          shape = 19) + 
  # Annotation for 0.95 quantile terminal point  
  annotate("text",
           x=-53, y=45,
           label = "Leading Edge",
           color = "black",
           size = 5,
           family = "serif") +
  # Blue to orange gradient for Year
  scale_color_gradient2(low ="#005A9C",       ##"#0072B2", "#003366",  #"steelblue3"
                        mid = "#FFD700",      #yellow", 
                        high =  "orangered",  #"#D55E00",
                        midpoint = 2005, 
                        name = "Year") + 
  # Labels and plot range
  xlab("Range Edge W to E") +
  ylab("Range Edge S to N") +
  coord_sf(xlim = c(-80, -44), ylim = c(35, 55), expand = FALSE) +
  # Theme
  theme_bw() +
  theme(
    legend.position = "right",
    plot.margin = margin(5, 10, 10, 10),
    axis.text.x = element_text(size = 14, 
                               family = "serif"),
    axis.text.y = element_text(size = 14, 
                               family = "serif"),
    axis.title.x = element_text(size = 14, 
                                hjust = 0.5, 
                                vjust = -2, 
                                family = "serif"),
    axis.title.y = element_text(size = 14, 
                                hjust = 0.5, 
                                vjust = 4, 
                                angle = 90, 
                                family = "serif"),
    legend.title = element_blank(),
    legend.text = element_text(size = 14, family = "serif"),
    strip.text = element_text(size = 14, 
                              family = "serif", 
                              angle = 0),
    strip.background = element_rect(colour = "black", 
                                    fill = "white"),
    panel.grid.minor = element_blank(), panel.grid.major =  element_blank(),
  )

RangeEdge_Mapped
```

## 5. Centre of Gravity

**Data: POC_COG.csv**

The average latitude and longitude, weighted by abundance 

* Region: USA, Canada

* Year: 1990-2023 

* centroid_longitude & centroid_latitude : weighted mean 

* **Removed** centroid_latitude_Median & centroid_longitude_Median: weighted median

* **Removed** centroid_latitude_Quantile_05 & centroid_longitude_Quantile_05: weighted 5th percentile 

* **Removed** centroid_latitude_Quantile_95 & centroid_longitude_Quantile_95: weighted 95th percentile

```{r COG data, echo=FALSE}
POC_COG<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_COG_manipulated.csv"))
str(POC_COG)

```

### Timeseries: Centre of Gravity (Mean)
```{r COG plot, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=9}

POC_COG_sf <- st_as_sf(POC_COG, coords = c("centroid_longitude", "centroid_latitude"))
st_crs(POC_COG_sf) <- crs

#Create one directional arrows to show th showing the overall movement (from MakingMapArrowsandTables.r)
arrow_dataRegion <- POC_COG_sf %>%
  group_by(Region) %>%
  summarize(
    start_point = first(geometry[Year == min(Year)]),  
    end_point = first(geometry[Year == max(Year)]),  
    start_year = min(Year),  # Get the start year
    end_year = max(Year)  
  ) %>%
  mutate(
    start_coords = st_coordinates(start_point),
    end_coords = st_coordinates(end_point),
    x = start_coords[,1],
    y = start_coords[,2],
    xend = end_coords[,1],
    yend = end_coords[,2],
    dx = xend - x,          
    dy = yend - y,          
    d_total = distHaversine(cbind(x, y), cbind(xend, yend))/1000,  # Great-circle distance in meters
    years_in_period = end_year - start_year,  # Compute the number of years in the period
    dist_per_year = d_total / years_in_period   # Distance per year
  ) %>%
  dplyr::select(Region,  x, y, xend, yend,d_total, dist_per_year) %>%
  st_drop_geometry()

#Plot COG map with arrows 
COG_Reg_map<-ggplot() +
  geom_sf(data = contours, color="lightblue", linewidth = .4) +
  geom_sf(data = All_region,  fill = NA) +
  geom_sf(data = NAFO, color="dimgrey", fill = NA) +
  geom_sf(data = AdminiBoder, color="black", linewidth = 1) +
  geom_sf(data = EEZ, color="black", linetype = "dashed", linewidth  = 1) +
  geom_sf(data = Land , color = "black", fill = "cornsilk") +
  #geom_sf(data = contours, color="lightblue",lwd=.5) +
  #geom_sf(data = NAFO, color="black",lty=1,lwd=.8,fill = NA) +
  #geom_sf(data = EEZ, color="black",lty=1,lwd=.8) +
  #geom_sf(data = AdminiBoder,  fill = NA,lty=1,lwd=.8) +
  #geom_sf(data = land, fill = "cornsilk") +  
  geom_sf(data = POC_COG_sf, aes(color = Year),size =3, alpha = .5,shape=16) +  
  xlim(-80, -44) + ylim(35, 55)+
  labs(title = "", x = "",y = "",
       color = "Year") +
  scale_color_gradient2(low = "steelblue3",   mid = "yellow", 
                        high = "orangered", 
                        midpoint = 2005, 
                        name = "Year",limits = range(POC_COG$Year)) +
  geom_segment(data = arrow_dataRegion,
               aes(x = x + 0.4,        # Offset values
                   y = y + 0.4, 
                   xend = xend + 0.4, 
                   yend = yend + 0.4),
               arrow = arrow(length = unit(0.35, "cm")),
               color = "black",
               alpha = .7,
               size = 2)+
  annotate("text",x=-70,y=44.5,label="USA", vjust = 0,color = "black",size = 4) +
  annotate("text",x=-65.9,y=46,label="Canada", vjust = 0,color = "black",size = 4) +
  # #a
  theme_bw()+
  theme(legend.position = "right",
    plot.margin = margin(5, 10, 10, 10),
    axis.text.x = element_text(size = 14, 
                               family = "serif"),
    axis.text.y = element_text(size = 14, 
                               family = "serif"),
    axis.title.x = element_text(size = 14, 
                                hjust = 0.5, 
                                vjust = -2, 
                                family = "serif"),
    axis.title.y = element_text(size = 14, 
                                hjust = 0.5, 
                                vjust = 4, 
                                angle = 90, 
                                family = "serif"),
    legend.title = element_blank(),
    legend.text = element_text(size = 14, family = "serif"),
    strip.text = element_text(size = 14, 
                              family = "serif", 
                              angle = 0),
    strip.background = element_rect(colour = "black", 
                                    fill = "white"),
    panel.grid.minor = element_blank(), panel.grid.major =  element_blank(),
  )
COG_Reg_map

```

## 6. Distance from COG to Shared Border

**Data: POC_DtoB.csv**

The distance between the closest point on the border to each COG metric in the time series and grouping,

* Region: USA, Canada

* Year: 1990-2023

* Dist_Mean: Distance (km), between the closest point on the shared border and the COG(weighted mean) for each year/region

* Dist_Mean, Dist_Q5, Dist_Q95: Distance to COG (weighted median, weighted 5th percentile, and 95th percentile, respectively)

```{r DtoB data, echo=FALSE}
POC_DtoB<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/NewData_NoCountries/POC_DtoB_manipulated.csv"))
str(POC_DtoB)

```

### Timeseries: Distance to Shared Border 

```{r DtoB plot, echo=FALSE, fig.width=6, fig.height=4}
ggplot(POC_DtoB, 
       aes(x = Year, y = Dist_Mean, colour = Region, group = Region)) +
  geom_line() +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed", linewidth = 0.8)+
  theme_bw() +
  labs(x = "Year", y = "Distance (km)",
       colour = "Region", fill = "Region")

```

## 7. Scaled Slopes

lm slopes for 2006-2023 (the period when the water began warming rapidly), scaled  so that all indicators are in the same units

```{r slopes data, echo=FALSE}
Scaled_Slopes<-read.csv(here::here("Data/Data_SHinyApp_Proof_of_Concept/Scaled_Slopes_all_indicators.csv"))
str(Scaled_Slopes)
 Scaled_Slopes$p.significant <- factor(Scaled_Slopes$p.significant, 
                          levels = c("Very strong", "Strong","Moderate",  "Not significant"))

 ggplot(Scaled_Slopes, 
        aes(x = estimate, 
            y = Indicator, 
            colour = Region,
            size = p.significant)) +
   geom_point(position = position_dodge(width = 0.6)) +
   scale_size_manual(
     values = c(
       "Very strong" = 4,   
       "Strong" = 3,
       "Moderate" = 2,
       "Not significant" = 1
     )
   ) +
   geom_errorbar(aes(xmin = conf.low, xmax = conf.high), 
                 width = 0.2, 
                 position = position_dodge(width = 0.6),
                 linewidth = 0.6) +  # fixed bar thickness
   geom_vline(xintercept = 0, linetype = "dashed", colour = "grey50") +
   theme_minimal(base_size = 14) +
   labs(
     x = "Estimated slope (±95% CI)",
     y = "",
     colour = "Region",
     size = "Significance",
     title = "2006–2023 Trends"
   ) +
   theme(
     panel.grid.minor = element_blank(),
     axis.title.y = element_text(margin = margin(r = 10))
   )
```


